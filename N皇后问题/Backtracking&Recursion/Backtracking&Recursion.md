# Backtracking&Recursion

## 程序设计与算法分析

### 初步想法

- 放置皇后
    - 先在第一列放皇后，再放第二列......直到放到第N列。
    - 每次在放第i列，第j行时，判断是否发生攻击
        - 攻击，则移除第i列原位置的皇后
            - 原位置皇后在第N行，则移除第i-1列原位置的皇后，执行类似的递归行为。
            - 原位置皇后不在第N行，则放置第i列皇后于j+1行。
        - 不攻击，记录位置
    
### 代码实现

由初步想法进一步分析， **确定每列皇后的位置** ，都是相同的操作过程。  
是否攻击，攻击则移到下一行，移到最后一行仍攻击则 **失败** ；否则 **成功** 。  
这些相同的操作过程如何联系在一起呢？一种方法是通过递归函数。如果 **成功** 则调用下一列的递归函数，到N列 **停止** 。如果 **失败** ，需要对上一列调整。

	int validState {
		//验证是否有攻击，攻击则返回0，否则返回1
		//注意初始条件，即col=0时
	}
	int Q_n (col) {
		row=0;
		while (row<N) {
			if (validState(row,col)) { //不攻击
				//记录位置
				Q_n (col+1);		
			}
			row++;
		}
		return 0;
	}
	Q_n (0); 
	
如果`while`循环结束仍没有进入下一层递归，函数直接返回0，返回后进入其上一层递归，开始`while`循环。  
但是以上，代码还存在问题。    
什么时候 **递归停止** 呢？ **col到了N的时候**，已经找到N个皇后布局了。（否则，第一列的row会加到N，跳出`while`，返回0。）

![Backtracking&Recursion](./Backtracking&Recursion.gif)